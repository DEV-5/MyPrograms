/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "main.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/* Function Prototypes */
void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);

void init_systick_timer(uint32_t tick_hz);
__attribute__((naked)) void init_scheduler_stack(uint32_t sched_top_of_stack);
void init_task_stack(void);
void enable_processor_faults(void);
void UsageFault_Handler_c(uint32_t *pBaseStackFrame);
__attribute__ ((naked)) void switch_sp_to_psp(void);
uint32_t get_psp_value(void);
void save_psp_value (uint32_t current_psp_value);
void update_next_task(void);
uint32_t sum(uint32_t a, uint32_t b, uint32_t c, uint32_t d, uint32_t e, uint32_t f);


/* Global variables */

uint32_t psp_of_tasks[MAX_TASKS] = {T1_STACK_START, T2_STACK_START, T3_STACK_START, T4_STACK_START};
uint8_t	current_task = 0; //Task 1 is running

int main(void)
{

	uint32_t res = sum(12, 13, 14, 15, 16, 17);
	enable_processor_faults();
	init_scheduler_stack(SCHED_STACK_START);
	init_task_stack();
	init_systick_timer(TICK_HZ);
	switch_sp_to_psp();

	task1_handler();

	printf("About to loop forever\r\n");
    /* Loop forever */
	for(;;);
}

void task1_handler(void)
{
	while(1)
	{
		printf("This is task 1\r\n");
	}
}

void task2_handler(void)
{
	while(1)
	{
		printf("This is task 2\r\n");
	}
}

void task3_handler(void)
{
	while(1)
	{
		printf("This is task 3\r\n");
	}
}

void task4_handler(void)
{
	while(1)
	{
		printf("This is task 4\r\n");
	}
}

void init_systick_timer(uint32_t tick_hz)
{
	uint32_t count = (SYSTICK_CLK/ tick_hz) - 1;
	uint32_t *pSRVR = (uint32_t*)SYST_RVR;
	uint32_t *pSCVR = (uint32_t*)SYST_CSR;

	/* clear SysTick RVR */
	*pSRVR &= ~(0x00FFFFFF);
	*pSRVR |= count;

	/* Enable SysTick exception Request */
	*pSCVR |= SYST_CSR_TICKINT_BIT;
	/* select SysTick clock source as processor clock */
	*pSCVR |= SYST_CSR_CLRSRC_BIT;
	/* Enable the counter */
	*pSCVR |= SYST_CSR_ENABLE_BIT;
}

__attribute__((naked)) void init_scheduler_stack(uint32_t sched_top_of_stack)
{
	__asm volatile ("MSR MSP,%0"::"r"(sched_top_of_stack):);
	__asm volatile ("BX LR");
}

static void moidifyPSP(uint32_t * pPSP, uint32_t data)
{
	(*pPSP) = data;
}

void init_task_stack(void)
{
	uint32_t * pPSP;

	for (int i = 0; i < MAX_TASKS; i++)
	{
		pPSP = (uint32_t *) psp_of_tasks[i];

		/* Init XPSR  value */
		moidifyPSP(--pPSP, DUMMY_XPSR);

		/* Init PC  value */
		moidifyPSP(--pPSP, psp_of_tasks[i]);

		/* Init LR  value */
		moidifyPSP(--pPSP, EXC_RETURN_THREAD_PSP_NO_FPU);

		for (int itr = 0; itr < 12; itr++)
		{
			moidifyPSP(--pPSP, 0);
		}
//		pPSP--;
//		pPSP = DUMMY_XPSR;

		psp_of_tasks[i] = (uint32_t) pPSP;
	}
}

void enable_processor_faults(void)
{
	//1. enable all configurable exceptions : usage fault, mem manage fault and bus fault
	uint32_t *pSHCSR = (uint32_t*)0xE000ED24;

	*pSHCSR |= ( 1 << 16); //mem manage
	*pSHCSR |= ( 1 << 17); //bus fault
	*pSHCSR |= ( 1 << 18); //usage fault
}


//2. implement the fault handlers
void HardFault_Handler(void)
{
	printf("Exception : Hardfault\n");
	while(1);
}


void MemManage_Handler(void)
{
	printf("Exception : MemManage\n");
	while(1);
}

void BusFault_Handler(void)
{
	printf("Exception : BusFault\n");
	while(1);
}

__attribute__ ((naked)) void UsageFault_Handler(void)
{
	//here we extracted the value of MSP which happens to be the
	//base address of the stack frame(thread mode) which got saved during the exception entry
	//from thread mode to handler mode
	__asm ("MRS r0,MSP");
	__asm ("B UsageFault_Handler_c");
}

void UsageFault_Handler_c(uint32_t *pBaseStackFrame)
{
	uint32_t *pUFSR = (uint32_t*)0xE000ED2A;
	printf("Exception : UsageFault\n");
	printf("UFSR = %lx\n",(*pUFSR) & 0xFFFF);
	printf("pBaseStackFrame = %p\n",pBaseStackFrame);
	printf("Value of R0 = %lx\n", pBaseStackFrame[0]);
	printf("Value of R1 = %lx\n", pBaseStackFrame[1]);
	printf("Value of R2 = %lx\n", pBaseStackFrame[2]);
	printf("Value of R3 = %lx\n", pBaseStackFrame[3]);
	printf("Value of R12 = %lx\n", pBaseStackFrame[4]);
	printf("Value of LR = %lx\n", pBaseStackFrame[5]);
	printf("Value of PC = %lx\n", pBaseStackFrame[6]);
	printf("Value of XPSR = %lx\n", pBaseStackFrame[7]);
	while(1);
}

uint32_t get_psp_value(void)
{
	return psp_of_tasks[current_task];
}

void save_psp_value (uint32_t current_psp_value)
{
	psp_of_tasks[current_task] = current_psp_value;
}

void update_next_task(void)
{
	current_task++;
	current_task %= MAX_TASKS;
}

uint32_t sum(uint32_t a, uint32_t b, uint32_t c, uint32_t d, uint32_t e, uint32_t f)
{
	return (a + b + c + d + e + f);
}
__attribute__ ((naked)) void switch_sp_to_psp(void)
{
	// Initialize the PSP with task1 stack start address
	__asm volatile ("PUSH {LR}"); // Preserve LR which connects back to main()
	__asm volatile ("BL get_psp_value"); // returns psp value in R0
	__asm volatile ("MSR PSP, R0"); //initlalize PSP
	__asm volatile ("POP {LR}"); // pops back LR value

	// Change SP to PSP using CONTROL register
	__asm volatile ("MOV R0,#0x02");
	__asm volatile ("MSR CONTROL, R0"); // set PSP as SP
	__asm volatile ("BX LR");
}

__attribute__ ((naked)) void SysTick_Handler(void)
{
	/* Save Context of current task */
	/* 1) Get current running task's PSP value */
	__asm volatile ("MRS R0, PSP");
	/* 2) Using that PSP value store SF2(R4 to R11) */
	__asm volatile ("STMDB R0!, {R4-R11}");
	/* save LR before function call will change the LR  */
	__asm volatile ("PUSH {LR}");
	/* 3) Save Current value of PSP */
	__asm volatile ("BL save_psp_value");

	/* Retrieve Context of next task */
	/* 1) Select next task to run */
	__asm volatile ("BL update_next_task");
	/* 2) get its past PSP value */
	__asm volatile ("BL get_psp_value"); // returns psp value in R0

	/* 3) Using that PSP value retrieve SF2(R4 to R11) */
	__asm volatile ("LDMIA R0!, {R4-R11}");
	/* 4) Update PSP and Exit */
	__asm volatile ("MSR PSP, R0"); //initlalize PSP

	__asm volatile ("POP {LR}");
	__asm volatile ("BX LR");
}


